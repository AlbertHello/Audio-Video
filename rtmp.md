 2020年9月7日 北京 阴有雨，但中午可热了
 RTMP 笔记
### 握手
![](resource/rtmp/01.png)

* client: 客户端需要发 3 个包。C0,C1,C2
* server: 服务端也需要发同样 3 个包。 S0,S1,S2

#### 开始握手
* 客户端发送 C0,C1，此时客户端处于等待状态。客户端有两个限制：
    * 客户端在未接受到 S1 之前不能发送 C2 包
    * 客户端在未接收到 S2 之前不能发送任何实际数据包

* 服务端在接受到 C0，发送 S0，S1 包。也可以等到接受到 C1 之后再一起发送，C1 包的等待不是必须的。此时，服务端处于等待状态。服务端有两个限制：
    * 服务端在未接受到 C1 之前不能发送 S2.
    * 服务端在未接收到 C2 之前不能发送任何实际数据包

* 客户端接受到 S1/S0 包后，发送 C2 包。
* 服务端接受到 C2 包后，返回 S2 包，并且此时握手已经完成。

**备注：**
* 实际并不是严格按照上面的规则来，rtmp并不是强安全的协议，有一种通用模式：
    * C0+C1
    * S0+S1+S2
    * C2
        * Client发送带有1byte的C0和固定长度为1536byte的C1。 
        * Server发送S0S1S2给Client。
        * Client发送C2。

#### C0 和 S0 消息格式
![](resource/rtmp/02.png)
* C0 和 S0 的长度为 1B，也就是一个字节，它的主要工作是确定 RTMP 的版本号。
* C0：客户端发送其所支持的 RTMP 版本号：3~31。一般都是写 3。
* S0：服务端返回其所支持的版本号。如果没有客户端的版本号，默认返回 3。

**备注**
* 0-2 是早期产品所用的，已被丢弃；4-31 保留在未来使用 ； 32-255 不允许使用 （为了区分其他以某一字符开始的文本协议）。如果服务无法识别客户端请求的版本，应该返回 3 。客户端可以选择减到版本 3 或选择取消握手

#### C1 和 S1 消息格式
![](resource/rtmp/03.png)

* time： 4 字节，本字段包含时间戳。
* zero： 4 字节，本字段必须是全零。
* random： 1528 字节。主要内容就是随机值

**备注**
* time该时间戳应该是发送这个数据块的端点的后续块的时间起始点。可以是 0， 或其他的任何值。为了同步多个流，端点可能发送其块流的当前值。
* zero字段必须是全零
* random字段可以包含任何值。因为每个端点必须用自己初始化的握手和对端初始化的握
手来区分身份，所以这个数据应有充分的随机性。但是并不需要加密安全的随机值，或
者动态值。

#### C2 和 S2 消息格式
C2 和 S2 消息有 1536 字节长。 只是 S1 和 C1 的回复。
![](resource/rtmp/04.png)

* time: 4个字节，时间戳，同上，也不是很重要
* time2: 4个字节，C1/S1 发送的时间戳。
* random: S1/C1 发送的随机数。长度为 1528B。

**备注**
* time字段必须包含对等段发送的时间（对 C2 来说是 S1，对 S2 来说是 C1）。
* time2字段必须包含先前发送的并被对端读取的包的时间戳
* random字段必须包含对端发送的随机数据字段（对 C2 来说是 S1，对 S2 来说是 C1）。
每个对等端可以用time和time2字段中的时间戳来快速地估计带宽和延迟。 但这样做可
能并不实用。

### Chunk 块
#### 分块
* 握手之后，连接开始复用一个或多个块流。 每个块流承载来自一个消息流的一类消
息。 每个被创建的块都关联到一个唯一的块流 ID。 所有的块都通过网络传输。在传输过
程中，必须一个块发送完之后再发送下一个块。 在接收端，每个块都根据块 ID 被收集成
消息
* 分块使高层协议的大消息分割成小的消息，保证大的低优先级消息不阻塞小的高优
先级消息
* 分块把原本应该消息中包含的信息压缩在块头中减少了小块消息发送的开销。块大小是可配置的。这个可以在 7.1 节中描述的块消息中完成。 最大块是 65535 字节，最小块是 128 字节。块越大 CPU 使用率越低，但是也导致大的写入，在低带宽下产生其他内容的延迟。块大小对每个方向都保持独立。

#### 块格式
块由头和数据组成，块头由三部分组成，结构如下：
![](resource/rtmp/05.png)
* basic header: 1到3个字节
    * 本字段包含块流 ID(chunk stream id) 和块类型(fmt)。
    * fmt决定编码的消息头的格式。
    * 本字段长度取决于块流ID，块流 ID 是可变长字段。
* message header：0， 3， 7 或 11 字节
    * 本字段编码要发送的消息的信息。本字段的长度，取决于块头中指定的块类型
* 扩展时间戳： 0 个或 4 字节 
    * 本字段必须在发送普通时间戳（普通时间戳是指message header中的时间戳） 设置为0xffffff 时发送，正常时间戳为其他值时都不应发送本值。当普通时间戳的值小于 0xffffff时，本字段不用出现，而应当使用正常时间戳字段。

#### Basic Header (1~3 byte)
* basic header包括块流ID（csid）和块类型(fmt)。块类型决定message header的
格式。basic header可能是 1， 2 或 3 个字节。这取决于块流 ID。
* rtmp最多支持65597个ID为3–65599的流。 ID 0、1和2作为保留值。 
    * 值0表示ID范围为64-319（第二个字节+ 64）。 
    * 值1表示ID范围为64-65599（（第三个字节）* 256 +第二个字节+ 64）。 
    * 值2指示其低级协议消息，没有额外的字节描述流id
    * 3–63范围内的值表示完整的流ID，没有用于表示它的其他字节。

##### 块流 ID 3-63 可用 1 字节来表示
![](resource/rtmp/06.png)

##### 块流 ID 64-319 可以用 2 字节表示 
![](resource/rtmp/07.png)

* 注意上面的 cs id - 64。这个代表的是第二个字节+64

##### 块流 ID64-65599 可以用 3 字节表示
![](resource/rtmp/08.png)
* 上面的csid计算方式：为第三个字节*255+第二个字节+64


**总结：**
* csid: 占6位
    * 本字段表示范围在 3-63 的csID值，0和1表示basic header的2或3字节版本结构
* fmt: 占2位
    * 本字段表示message header的 4 种格式
* csid-64: 占 8-16 位
    * 本字段包含csid 减去 64 的值

**注意**
* 块流 ID 在 64-319 范围之内，可以用 2 个字节版本表示，也可以用 3 字节版本表示.