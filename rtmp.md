 2020年9月7日 北京 阴有雨，但中午可热了
 RTMP 笔记
### ShakeHands
![](resource/rtmp/01.png)

* client: 客户端需要发 3 个包。C0,C1,C2
* server: 服务端也需要发同样 3 个包。 S0,S1,S2

#### 握手步骤
* 客户端发送 C0,C1，此时客户端处于等待状态。客户端有两个限制：
    * 客户端在未接受到 S1 之前不能发送 C2 包
    * 客户端在未接收到 S2 之前不能发送任何实际数据包

* 服务端在接受到 C0，发送 S0，S1 包。也可以等到接受到 C1 之后再一起发送，C1 包的等待不是必须的。此时，服务端处于等待状态。服务端有两个限制：
    * 服务端在未接受到 C1 之前不能发送 S2.
    * 服务端在未接收到 C2 之前不能发送任何实际数据包

* 客户端接受到 S1/S0 包后，发送 C2 包。
* 服务端接受到 C2 包后，返回 S2 包，并且此时握手已经完成。

**备注：**
* 实际并不是严格按照上面的规则来，rtmp并不是强安全的协议，有一种通用模式：
    * C0+C1
    * S0+S1+S2
    * C2
        * Client发送带有1byte的C0和固定长度为1536byte的C1。 
        * Server发送S0S1S2给Client。
        * Client发送C2。
* 需要提及的是，RTMP 默认都是使用 Big-Endian 进行写入和读取，除非强调对某个字段使用 Little-Endian 字节序。

#### C0 和 S0 消息格式
![](resource/rtmp/02.png)
* C0 和 S0 的长度为 1B，也就是一个字节，它的主要工作是确定 RTMP 的版本号。
* C0：客户端发送其所支持的 RTMP 版本号：3~31。一般都是写 3。
* S0：服务端返回其所支持的版本号。如果没有客户端的版本号，默认返回 3。

**备注**
* 0-2 是早期产品所用的，已被丢弃；4-31 保留在未来使用 ； 32-255 不允许使用 （为了区分其他以某一字符开始的文本协议）。如果服务无法识别客户端请求的版本，应该返回 3 。客户端可以选择减到版本 3 或选择取消握手

#### C1 和 S1 消息格式
![](resource/rtmp/03.png)

* time： 4 字节，本字段包含时间戳。
* zero： 4 字节，本字段必须是全零。
* random： 1528 字节。主要内容就是随机值

**备注**
* time该时间戳应该是发送这个数据块的端点的后续块的时间起始点。可以是 0， 或其他的任何值。为了同步多个流，端点可能发送其块流的当前值。
* zero字段必须是全零
* random字段可以包含任何值。因为每个端点必须用自己初始化的握手和对端初始化的握
手来区分身份，所以这个数据应有充分的随机性。但是并不需要加密安全的随机值，或
者动态值。

#### C2 和 S2 消息格式
C2 和 S2 消息有 1536 字节长。 只是 S1 和 C1 的回复。
![](resource/rtmp/04.png)

* time: 4个字节，时间戳，同上，也不是很重要
* time2: 4个字节，C1/S1 发送的时间戳。
* random: S1/C1 发送的随机数。长度为 1528B。

**备注**
* time字段必须包含对等段发送的时间（对 C2 来说是 S1，对 S2 来说是 C1）。
* time2字段必须包含先前发送的并被对端读取的包的时间戳
* random字段必须包含对端发送的随机数据字段（对 C2 来说是 S1，对 S2 来说是 C1）。
每个对等端可以用time和time2字段中的时间戳来快速地估计带宽和延迟。 但这样做可
能并不实用。

### Chunk 块
#### Chunking 分块
* 握手之后，连接开始复用一个或多个块流。 每个块流承载来自一个消息流的一类消
息。 每个被创建的块都关联到一个唯一的块流 ID。 所有的块都通过网络传输。在传输过
程中，必须一个块发送完之后再发送下一个块。 在接收端，每个块都根据块 ID 被收集成
消息
* 分块使高层协议的大消息分割成小的消息，保证大的低优先级消息不阻塞小的高优
先级消息
* 分块把原本应该消息中包含的信息压缩在块头中减少了小块消息发送的开销。块大小是可配置的。这个可以在 7.1 节中描述的块消息中完成。 最大块是 65535 字节，最小块是 128 字节。块越大 CPU 使用率越低，但是也导致大的写入，在低带宽下产生其他内容的延迟。块大小对每个方向都保持独立。

#### Chunk 结构
块由header和data组成，header又由三部分组成，结构如下：
![](resource/rtmp/05.png)
* basic header: 1到3个字节
    * 本字段包含块流 ID(chunk stream id) 和块类型(fmt)。
    * fmt决定编码的消息头的格式。
    * 本字段长度取决于块流ID，块流 ID 是可变长字段。
* message header：0， 3， 7 或 11 字节
    * 本字段编码要发送的消息的信息。本字段的长度，取决于块头中指定的块类型
* 扩展时间戳： 0 个或 4 字节 
    * 本字段必须在发送普通时间戳（普通时间戳是指message header中的时间戳） 设置为0xffffff 时发送，正常时间戳为其他值时都不应发送本值。当普通时间戳的值小于 0xffffff时，本字段不用出现，而应当使用正常时间戳字段。

#### Basic Header (1~3 byte)
* RTMP 中的 Header 分为 Basic Header 和 Message Header。需要注意，他们两者并不是独立的，而是相互联系。Message Header 的结构由 Basic Header 的内容来决定。
* basic header包括块流ID（csid）和块类型(fmt)。块类型决定message header的
格式。basic header可能是 1， 2 或 3 个字节。这取决于块流 ID。
* rtmp最多支持65597个ID为3–65599的流。 ID 0、1和2作为保留值。 
    * 值0表示ID范围为64-319（第二个字节+ 64）。 
    * 值1表示ID范围为64-65599（（第三个字节）* 256 +第二个字节+ 64）。 
    * 值2指示其低级协议消息，没有额外的字节描述流id
    * 3–63范围内的值表示完整的流ID，没有用于表示它的其他字节。

##### 块流 ID 3-63 可用 1 字节来表示
![](resource/rtmp/06.png)

##### 块流 ID 64-319 可以用 2 字节表示 
![](resource/rtmp/07.png)

* 注意上面的 cs id - 64。这个代表的是第二个字节+64

##### 块流 ID64-65599 可以用 3 字节表示
![](resource/rtmp/08.png)
* 上面的csid计算方式：为第三个字节*255+第二个字节+64


**总结：**
* csid: 占6位
    * 本字段表示范围在 3-63 的csID值，0和1表示basic header的2或3字节版本结构
* fmt: 占2位
    * 本字段表示message header的 4 种格式
* csid-64: 占 8-16 位
    * 本字段包含csid 减去 64 的值

**注意**
* 块流 ID 在 64-319 范围之内，可以用 2 个字节版本表示，也可以用 3 字节版本表示.

#### Message Header (0， 3， 7 或 11 byte)
Basic header 中的fmt块类型决定了message header的大小，fmt占两位，总共四种

##### fmt=0
此类型下message header大小为11字节，在一个块流的开始和时间戳返回的时候必须有这种块
![](resource/rtmp/09.png)

* timestamp（时间戳）：占用3个字节
* message length（消息数据的长度）：占用3个字节，表示实际发送的消息的数据如音频帧、视频帧等数据的长度，单位是字节。注意这里是Message的长度，也就是chunk属于的Message的总数据长度，而不是chunk本身Data的数据的长度。
* message type id(消息的类型id)：占用1个字节，表示实际发送的数据的类型，如8代表音频数据、9代表视频数据。
* msg stream id（消息的流id）：占用4个字节，表示该chunk所在的流的ID，和Basic Header的CSID一样，**它采用小端存储的方式**

**备注**
* 对于该类型的块。timestamp：消息的绝对时间戳在这里发送。如果时间戳大于或等于16777215（16 进制 0x00ffffff），该值必须为 16777215，并且扩展时间戳必须出现。否则该值就是整个的时间戳。


##### fmt=1
此类型下message header占 7 个字节长。msg stream id 不包含在本块中, 表明当前块的msg stream id与先前的块相同。 具有可变大小消息的流，在第一个消息之后的每个消息的第一个块应该使用这个格式
![](resource/rtmp/10.png)

* 省去了表示msg stream id的4个字节，表示此chunk和上一次发的chunk所在的流相同
* timestamp delta：占用3个字节，注意这里和type＝0时的timestamp不同，此处timestamp delta存储的是和上一个chunk的时间差

##### fmt=2
类型 2 的块占 3 个字节。既不包含流 ID 也不包含消息长度。本块使用的流
ID 和消息长度与先前的块相同。具有固定大小消息的流，在第一个消息之后的
每个消息的第一个块应该使用这个格式
![](resource/rtmp/11.png)

* 相对于type＝1格式又省去了表示消息长度的3个字节和表示消息类型的1个字节，表示此chunk和上一次发送的chunk所在的流、消息的长度和消息的类型都相同
* 余下的这三个字节表示timestamp delta，意义同type＝1

##### fmt=3
类型3占用0字节，也就是没有message header，这种类型的块使用与先前块相同的数据。当一个消息被分成多个块，除了第一块以外，所有的块都应使用这种类型。
* 它表示这个chunk的Message Header和上一个是完全相同的。
* 当它跟在**fmt＝0**的chunk后面时，表示和前一个chunk的时间戳都是相同的。
    * 什么时候连时间戳都相同呢？就是一个Message拆分成了多个chunk，这个chunk和上一个chunk同属于一个Message。
* 当它跟在**fmt＝1**或者**fmt＝2**的chunk后面时，表示和前一个chunk的时间戳的差是相同的。
    * 比如第一个chunk的Type＝0，timestamp＝100，第二个chunk的Type＝2，timestamp delta＝20，表示时间戳为100+20=120，第三个chunk的Type＝3，表示timestamp delta＝20，时间戳为120+20=140

#### Extended Timestamp 扩展时间戳
![](resource/rtmp/12.png)
* 只有当块message header中的普通时间戳设置为 0x00ffffff 时，本字段才被传送。 
* 如果普通时间戳的值小于 0x00ffffff，那么本字段一定不能出现。
* 如果时间戳字段不出现本字段也一定不能出现。
* fmt=3的块一定不能含有本字段。
* 如果发送本字段，则该字段位于块message header之后，块data之前。
* 表示应该去扩展时间戳字段来提取真正的时间戳或者时间戳差
* 扩展时间戳存储的是完整值，而不是减去时间戳或者时间戳差的值
* 扩展时间戳占4个字节，能表示的最大数值就是0xFFFFFFFF＝4294967295

####  Chunk Data 块数据
用户层面上真正想要发送的与协议无关的数据，长度在(0,chunkSize]之间。

### 消息分块实例
#### 实例1
下面展示一个简单的音频消息流。这个例子显示了信息的冗余。
![](resource/rtmp/13.png)

而下表显示了这个流产生的块。从消息 3 开始，数据传输开始优化。在消息 3
之后，每个消息只有一个字节的开销
![](resource/rtmp/14.png)

* 首先包含第一个Message的chunk的Chunk Type为0，因为它没有前面可参考的chunk，timestamp为1000，表示时间戳。type为0的header占用11个字节，假定chunkstreamId为3<127，因此Basic Header占用1个字节，再加上Data的32个字节，因此第一个chunk共44＝11+1+32个字节。
* 第二个chunk和第一个chunk的CSID，TypeId，Data的长度都相同，因此采用Chunk Type＝2，timestamp delta＝1020-1000＝20，因此第二个chunk占用36=3+1+32个字节。
* 第三个chunk和第二个chunk的CSID，TypeId，Data的长度和时间戳差都相同，因此采用Chunk Type＝3省去全部Message Header的信息，占用33=1+32个字节。
* 第四个chunk和第三个chunk情况相同，也占用33=1+32个字节。

#### 实例2
下面演示一个消息由于太长，而被分割成 128 字节的块

未分块时：
![](resource/rtmp/15.png)
拆成块：
![](resource/rtmp/16.png)

* 注意到Data的Length＝307>128,因此这个Message要切分成几个chunk发送，第一个chunk的Type＝0，Timestamp＝1000，承担128个字节的Data，因此共占用140=11+1+128个字节。
* 第二个chunk也要发送128个字节，其他字段也同第一个chunk，因此采用Chunk Type＝3，此时时间戳也为1000，共占用129=1+128个字节。
* 第三个chunk要发送的Data的长度为307-128-128=51个字节，还是采用Type＝3，共占用1+51＝52个字节。

